var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Bonobo","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Bonobo]","category":"page"},{"location":"reference/#Bonobo.bound!-Tuple{BnBTree, Any}","page":"Reference","title":"Bonobo.bound!","text":"bound!(tree::BnBTree, current_node_id)\n\nClose all nodes which have a lower bound higher or equal to the incumbent\n\n\n\n\n\n","category":"method"},{"location":"reference/#Bonobo.initialize-Tuple{}","page":"Reference","title":"Bonobo.initialize","text":"initialize(; kwargs...)\n\nInitialize the branch and bound framework with the the following arguments. Later it can be dispatched on BnBTree{Node, Root, Solution} for various methods.\n\nKeyword arguments\n\ntraverse [:BFS] currently the only supported traverse strategy is BFS.\nNode DefaultNode can be special structure which is used to store all information about a node. \nneeds to have AbstractNode as the super type\nneeds to have std :: BnBNode as a field (see BnBNode)\nSolution DefaultSolution stores the node and several other information about a solution\nroot [nothing] the information about the root problem. The type can be used for dispatching on types \nsense [:Min] can be :Min or :Max depending on the objective sense\nValue [Vector{Float64}] the type of a solution  \n\nReturn a BnBTree object which is the input for optimize!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Bonobo.optimize!-Tuple{BnBTree}","page":"Reference","title":"Bonobo.optimize!","text":"optimize!(tree::BnBTree)\n\nOptimize the problem using a branch and bound approach. \n\nThe steps are the following:\n\nwhile !terminated(tree) # as long as there are open nodes\n    # get the next open node depending on the traverse strategy\n    node = get_next_node(tree) \n    # needs to be implemented by you\n    # Should evaluate the current node and return the lower and upper bound\n    # if the problem is infeasible both values should be set to NaN\n    lb, ub = evaluate_node!(tree, node) \n    # updates the upper and lower bound of the node struct\n    set_node_bound!(tree.sense, node, lb, ub)\n\n    # update the best solution \n    updated = update_best_solution!(tree, node)\n    updated && bound!(tree, node.id)\n    \n    # remove the current node\n    close_node!(tree, node)\n    # needs to be implemented by you\n    # create branches from the current node\n    branch!(tree, node)\nend\n\nevery function of the above can be overriden by your own method. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Bonobo.set_node_bound!-Tuple{Symbol, AbstractNode, Any, Any}","page":"Reference","title":"Bonobo.set_node_bound!","text":"set_node_bound!(objective_sense::Symbol, node::AbstractNode, lb, ub)\n\nSet the bounds of the node object to the lower and upper bound given.  Internally everything is stored as a minimization problem. Therefore the objective_sense :Min/:Max is needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Bonobo.terminated-Tuple{BnBTree}","page":"Reference","title":"Bonobo.terminated","text":"terminated(tree::BnBTree)\n\nReturn true when the branch and bound loop in optimize! should be terminated. Default behavior is to terminate the loop only when no nodes exist in the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Bonobo","category":"page"},{"location":"#Bonobo","page":"Home","title":"Bonobo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Bonobo.","category":"page"},{"location":"how_to/#How-To-Guide","page":"How-To","title":"How-To Guide","text":"","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
