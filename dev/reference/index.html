<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Bonobo.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Wikunia.github.io/Bonobo.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bonobo.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../how_to/">How-To</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Wikunia/Bonobo.jl/blob/master/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Bonobo.AbstractBranchStrategy" href="#Bonobo.AbstractBranchStrategy"><code>Bonobo.AbstractBranchStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBranchStrategy</code></pre><p>The abstract type for a branching strategy.  If you implement a new branching strategy, this must be the supertype. </p><p>If you want to implement your own strategy, you must implement a new method for <a href="#Bonobo.get_branching_variable-Tuple{BnBTree, Bonobo.FIRST, AbstractNode}"><code>get_branching_variable</code></a> which dispatches on the <code>branch_strategy</code> argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.AbstractNode" href="#Bonobo.AbstractNode"><code>Bonobo.AbstractNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractNode</code></pre><p>The abstract type for a tree node. Your own type for <code>Node</code> given to <a href="#Bonobo.initialize-Tuple{}"><code>initialize</code></a> needs to subtype it. The default if you don&#39;t provide your own is <a href="#Bonobo.DefaultNode"><code>DefaultNode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.AbstractSolution" href="#Bonobo.AbstractSolution"><code>Bonobo.AbstractSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSolution{Node&lt;:AbstractNode, Value}</code></pre><p>The abstract type for a <code>Solution</code> object. The default is <a href="#Bonobo.DefaultSolution"><code>DefaultSolution</code></a>. It is parameterized by <code>Node</code> and <code>Value</code> where <code>Value</code> is the value which describes the full solution i.e the value for every variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.AbstractTraverseStrategy" href="#Bonobo.AbstractTraverseStrategy"><code>Bonobo.AbstractTraverseStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTraverseStrategy</code></pre><p>The abstract type for a traverse strategy.  If you implement a new traverse strategy this must be the supertype. </p><p>If you want to implement your own strategy the <a href="#Bonobo.get_next_node-Tuple{BnBTree, Bonobo.BestFirstSearch}"><code>get_next_node</code></a> function needs a new method  which dispatches on the <code>traverse_strategy</code> argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.BestFirstSearch" href="#Bonobo.BestFirstSearch"><code>Bonobo.BestFirstSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BestFirstSearch &lt;: AbstractTraverseStrategy</code></pre><p>The BestFirstSearch traverse strategy always picks the node with the lowest bound first. If there is a tie then the smallest node id is used as a tie breaker.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.BnBNodeInfo" href="#Bonobo.BnBNodeInfo"><code>Bonobo.BnBNodeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BnBNodeInfo</code></pre><p>Holds the necessary information of every node. This needs to be added by every <code>AbstractNode</code> as <code>std::BnBNodeInfo</code></p><pre><code class="language-julia hljs">id :: Int
lb :: Float64
ub :: Float64
depth :: Int</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.BnBTree" href="#Bonobo.BnBTree"><code>Bonobo.BnBTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BnBTree{Node&lt;:AbstractNode,Root,Value,Solution&lt;:AbstractSolution{Node,Value}}</code></pre><p>Holds all the information of the branch and bound tree. </p><pre><code class="language-julia hljs">incumbent::Float64 - The best objective value found so far. Is stores as problem is a minimization problem
incumbent_solution::Solution - The currently best solution object
lb::Float64        - The highest current lower bound 
solutions::Vector{Solution} - A list of solutions
node_queue::PriorityQueue{Int,Tuple{Float64, Int}} - A priority queue with key being the node id and the priority consists of the node lower bound and the node id.
nodes::Dict{Int, Node}  - A dictionary of all nodes with key being the node id and value the actual node.
root::Root      - The root node see [`set_root!`](@ref)
branching_indices::Vector{Int} - The indices to be able to branch on used for [`get_branching_variable`](@ref)
num_nodes::Int  - The number of nodes created in total
sense::Symbol   - The objective sense: `:Max` or `:Min`.
options::Options  - All options for the branch and bound tree. See [`Options`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L130-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.DefaultNode" href="#Bonobo.DefaultNode"><code>Bonobo.DefaultNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultNode &lt;: AbstractNode</code></pre><p>The default structure for saving node information. Currently this includes only the necessary <code>std::BnBNodeInfo</code> which needs to be part of every <a href="#Bonobo.AbstractNode"><code>AbstractNode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.DefaultSolution" href="#Bonobo.DefaultSolution"><code>Bonobo.DefaultSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultSolution{Node&lt;:AbstractNode,Value} &lt;: AbstractSolution{Node, Value}</code></pre><p>The default struct to save a solution of the branch and bound run. It holds</p><pre><code class="language-julia hljs">objective :: Float64
solution  :: Value
node      :: Node</code></pre><p>Both the <code>Value</code> and the <code>Node</code> type are determined by the <a href="#Bonobo.initialize-Tuple{}"><code>initialize</code></a> method.</p><p><code>solution</code> holds the information to obtain the solution for example the values of all variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L52-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.FIRST" href="#Bonobo.FIRST"><code>Bonobo.FIRST</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FIRST &lt;: AbstractBranchStrategy</code></pre><p>The <code>FIRST</code> strategy always picks the first variable which isn&#39;t fixed yet and can be branched on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.MOST_INFEASIBLE" href="#Bonobo.MOST_INFEASIBLE"><code>Bonobo.MOST_INFEASIBLE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MOST_INFEASIBLE &lt;: AbstractBranchStrategy</code></pre><p>The <code>MOST_INFEASIBLE</code> strategy always picks the variable which is furthest away from being &quot;fixed&quot; and can be branched on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.add_new_solution!-Union{Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}, Tuple{BnBTree{N, R, V, S}, AbstractNode}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}" href="#Bonobo.add_new_solution!-Union{Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}, Tuple{BnBTree{N, R, V, S}, AbstractNode}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}"><code>Bonobo.add_new_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_new_solution!(tree::BnBTree{N,R,V,S}, node::AbstractNode) where {N,R,V,S&lt;:DefaultSolution{N,V}}</code></pre><p>Currently it changes the general solution itself by calling <a href="#Bonobo.get_relaxed_values"><code>get_relaxed_values</code></a> which needs to be implemented by you.</p><p>This function needs to be implemented by you if you have a different type of Solution object than <a href="#Bonobo.DefaultSolution"><code>DefaultSolution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L391-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.add_node!-Union{Tuple{Node}, Tuple{BnBTree{Node, Root, Value, Solution} where {Root, Value, Solution&lt;:AbstractSolution{Node, Value}}, Union{Nothing, AbstractNode}, NamedTuple}} where Node&lt;:AbstractNode" href="#Bonobo.add_node!-Union{Tuple{Node}, Tuple{BnBTree{Node, Root, Value, Solution} where {Root, Value, Solution&lt;:AbstractSolution{Node, Value}}, Union{Nothing, AbstractNode}, NamedTuple}} where Node&lt;:AbstractNode"><code>Bonobo.add_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_node!(tree::BnBTree{Node}, parent::Union{AbstractNode, Nothing}, node_info::NamedTuple)</code></pre><p>Add a new node to the tree using the <code>node_info</code>. For information on that see <a href="#Bonobo.set_root!-Tuple{BnBTree, NamedTuple}"><code>set_root!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/node.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.bound!-Tuple{BnBTree, Int64}" href="#Bonobo.bound!-Tuple{BnBTree, Int64}"><code>Bonobo.bound!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bound!(tree::BnBTree, current_node_id::Int)</code></pre><p>Close all nodes which have a lower bound higher or equal to the incumbent</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L352-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.branch!-Tuple{Any, Any}" href="#Bonobo.branch!-Tuple{Any, Any}"><code>Bonobo.branch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branch!(tree, node)</code></pre><p>Get the branching variable with <a href="#Bonobo.get_branching_variable-Tuple{BnBTree, Bonobo.FIRST, AbstractNode}"><code>get_branching_variable</code></a> and then calls <a href="#Bonobo.get_branching_nodes_info"><code>get_branching_nodes_info</code></a> and <a href="#Bonobo.add_node!-Union{Tuple{Node}, Tuple{BnBTree{Node, Root, Value, Solution} where {Root, Value, Solution&lt;:AbstractSolution{Node, Value}}, Union{Nothing, AbstractNode}, NamedTuple}} where Node&lt;:AbstractNode"><code>add_node!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/branching.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.close_node!-Tuple{BnBTree, AbstractNode}" href="#Bonobo.close_node!-Tuple{BnBTree, AbstractNode}"><code>Bonobo.close_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">close_node!(tree::BnBTree, node::AbstractNode)</code></pre><p>Delete the node from the nodes dictionary and the priority queue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.create_node-Tuple{Any, Int64, Union{Nothing, AbstractNode}, NamedTuple}" href="#Bonobo.create_node-Tuple{Any, Int64, Union{Nothing, AbstractNode}, NamedTuple}"><code>Bonobo.create_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_node(Node, node_id::Int, parent::Union{AbstractNode, Nothing}, node_info::NamedTuple)</code></pre><p>Creates a node of type <code>Node</code> with id <code>node_id</code> and the named tuple <code>node_info</code>.  For information on that see <a href="#Bonobo.set_root!-Tuple{BnBTree, NamedTuple}"><code>set_root!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/node.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.evaluate_node!" href="#Bonobo.evaluate_node!"><code>Bonobo.evaluate_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_node!(tree, node)</code></pre><p>Evaluate the current node and return the lower and upper bound of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/node.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_branching_indices" href="#Bonobo.get_branching_indices"><code>Bonobo.get_branching_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_branching_indices(root)</code></pre><p>Return a vector of variables to branch on from the current root object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_branching_nodes_info" href="#Bonobo.get_branching_nodes_info"><code>Bonobo.get_branching_nodes_info</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_branching_nodes_info(tree::BnBTree, node::AbstractNode, vidx::Int)</code></pre><p>Create the information for new branching nodes based on the variable index <code>vidx</code>. Return a list of those information as a <code>NamedTuple</code> vector.</p><p><strong>Example</strong></p><p>The following would add the necessary information about a new node and return it. The necessary information are the fields required by the <a href="#Bonobo.AbstractNode"><code>AbstractNode</code></a>. For this examle the required fields are the lower and upper bounds of the variables as well as the status of the node.</p><pre><code class="language-julia hljs">nodes_info = NamedTuple[]
push!(nodes_info, (
    lbs = lbs,
    ubs = ubs,
    status = MOI.OPTIMIZE_NOT_CALLED,
))
return nodes_info</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/branching.jl#L57-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_branching_variable-Tuple{BnBTree, Bonobo.FIRST, AbstractNode}" href="#Bonobo.get_branching_variable-Tuple{BnBTree, Bonobo.FIRST, AbstractNode}"><code>Bonobo.get_branching_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_branching_variable(tree::BnBTree, ::FIRST, node::AbstractNode)</code></pre><p>Return the first possible branching variable which is a branching variable based on <code>tree.branching_indices</code> and is currently not valid based on <a href="#Bonobo.is_approx_feasible-Tuple{BnBTree, Number}"><code>is_approx_feasible</code></a>. Return <code>-1</code> if all integer constraints are respected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/branching.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_branching_variable-Tuple{BnBTree, Bonobo.MOST_INFEASIBLE, AbstractNode}" href="#Bonobo.get_branching_variable-Tuple{BnBTree, Bonobo.MOST_INFEASIBLE, AbstractNode}"><code>Bonobo.get_branching_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_branching_variable(tree::BnBTree, ::MOST_INFEASIBLE, node::AbstractNode)</code></pre><p>Return the branching variable which is furthest away from being feasible based on <a href="#Bonobo.get_distance_to_feasible-Tuple{BnBTree, Number}"><code>get_distance_to_feasible</code></a> or <code>-1</code> if all integer constraints are respected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/branching.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_distance_to_feasible-Tuple{BnBTree, Number}" href="#Bonobo.get_distance_to_feasible-Tuple{BnBTree, Number}"><code>Bonobo.get_distance_to_feasible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_distance_to_feasible(tree::BnBTree, value)</code></pre><p>Return the distance of feasibility for the given value.</p><ul><li>if <code>value::Number</code> this returns the distance to the nearest discrete value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/util.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_next_node-Tuple{BnBTree, Bonobo.BestFirstSearch}" href="#Bonobo.get_next_node-Tuple{BnBTree, Bonobo.BestFirstSearch}"><code>Bonobo.get_next_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_next_node(tree::BnBTree, ::BestFirstSearch)</code></pre><p>Get the next node of the tree which shall be evaluted next by <a href="#Bonobo.evaluate_node!"><code>evaluate_node!</code></a>. If you want to implement your own traversing strategy check out <a href="#Bonobo.AbstractTraverseStrategy"><code>AbstractTraverseStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/node.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_num_solutions-Tuple{BnBTree}" href="#Bonobo.get_num_solutions-Tuple{BnBTree}"><code>Bonobo.get_num_solutions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_solutions(tree::BnBTree)</code></pre><p>Return the number of solutions available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L438-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_objective_value-Union{Tuple{BnBTree{N, R, V, S}}, Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}" href="#Bonobo.get_objective_value-Union{Tuple{BnBTree{N, R, V, S}}, Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}"><code>Bonobo.get_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_objective_value(tree::BnBTree; result=1)</code></pre><p>Return the objective value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L425-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_relaxed_values" href="#Bonobo.get_relaxed_values"><code>Bonobo.get_relaxed_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_relaxed_values(tree::BnBTree, node::AbstractNode)</code></pre><p>Get the values of the current node. This is always called only after <a href="#Bonobo.evaluate_node!"><code>evaluate_node!</code></a> is called. It is used to store a <code>Solution</code> object. Return the type of <code>Value</code> given to the <a href="#Bonobo.initialize-Tuple{}"><code>initialize</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L406-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.get_solution-Union{Tuple{BnBTree{N, R, V, S}}, Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}" href="#Bonobo.get_solution-Union{Tuple{BnBTree{N, R, V, S}}, Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}"><code>Bonobo.get_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_solution(tree::BnBTree; result=1)</code></pre><p>Return the solution values of the problem.  See <a href="#Bonobo.get_objective_value-Union{Tuple{BnBTree{N, R, V, S}}, Tuple{S}, Tuple{V}, Tuple{R}, Tuple{N}} where {N, R, V, S&lt;:Bonobo.DefaultSolution{N, V}}"><code>get_objective_value</code></a> to obtain the objective value instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L415-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.initialize-Tuple{}" href="#Bonobo.initialize-Tuple{}"><code>Bonobo.initialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize(; kwargs...)</code></pre><p>Initialize the branch and bound framework with the the following arguments. Later it can be dispatched on <code>BnBTree{Node, Root, Solution}</code> for various methods.</p><p><strong>Keyword arguments</strong></p><ul><li><code>traverse_strategy</code> [<code>BestFirstSearch</code>] currently the only supported traverse strategy is <a href="#Bonobo.BestFirstSearch"><code>BestFirstSearch</code></a>. Should be an <a href="#Bonobo.AbstractTraverseStrategy"><code>AbstractTraverseStrategy</code></a></li><li><code>branch_strategy</code> [<code>FIRST</code>] currently the only supported branching strategies are <a href="#Bonobo.FIRST"><code>FIRST</code></a> and <a href="#Bonobo.MOST_INFEASIBLE"><code>MOST_INFEASIBLE</code></a>. Should be an <a href="#Bonobo.AbstractBranchStrategy"><code>AbstractBranchStrategy</code></a></li><li><code>atol</code> [1e-6] the absolute tolerance to check whether a value is discrete</li><li><code>rtol</code> [1e-6] the relative tolerance to check whether a value is discrete</li><li><code>Node</code> <a href="#Bonobo.DefaultNode"><code>DefaultNode</code></a> can be special structure which is used to store all information about a node. <ul><li>needs to have <code>AbstractNode</code> as the super type</li><li>needs to have <code>std :: BnBNodeInfo</code> as a field (see <a href="#Bonobo.BnBNodeInfo"><code>BnBNodeInfo</code></a>)</li></ul></li><li><code>Solution</code> <a href="#Bonobo.DefaultSolution"><code>DefaultSolution</code></a> stores the node and several other information about a solution</li><li><code>root</code> [<code>nothing</code>] the information about the root problem. The type can be used for dispatching on types </li><li><code>sense</code> [<code>:Min</code>] can be <code>:Min</code> or <code>:Max</code> depending on the objective sense</li><li><code>Value</code> [<code>Vector{Float64}</code>] the type of a solution  </li></ul><p>Return a <a href="#Bonobo.BnBTree"><code>BnBTree</code></a> object which is the input for <a href="#Bonobo.optimize!-Tuple{BnBTree}"><code>optimize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L169-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.is_approx_feasible-Tuple{BnBTree, Number}" href="#Bonobo.is_approx_feasible-Tuple{BnBTree, Number}"><code>Bonobo.is_approx_feasible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_approx_feasible(tree::BnBTree, value)</code></pre><p>Return whether a given <code>value</code> is approximately feasible based on the tolerances defined in the tree options. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/util.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.optimize!-Tuple{BnBTree}" href="#Bonobo.optimize!-Tuple{BnBTree}"><code>Bonobo.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize!(tree::BnBTree; callback=(args...; kwargs...)-&gt;())</code></pre><p>Optimize the problem using a branch and bound approach. </p><p>The steps, repeated until terminated is true, are the following:</p><pre><code class="language-julia hljs"># 1. get the next open node depending on the traverse strategy
node = get_next_node(tree, tree.options.traverse_strategy)
# 2. evaluate the current node and return the lower and upper bound
# if the problem is infeasible both values should be set to NaN
lb, ub = evaluate_node!(tree, node)
# 3. update the upper and lower bound of the node struct
set_node_bound!(tree.sense, node, lb, ub)

# 4. update the best solution
updated = update_best_solution!(tree, node)
updated &amp;&amp; bound!(tree, node.id)

# 5. remove the current node
close_node!(tree, node)
# 6. compute the node children and adds them to the tree
# internally calls get_branching_variable and branch_on_variable!
branch!(tree, node)</code></pre><p>A <code>callback</code> function can be provided which will be called whenever a node is closed. It always has the arguments <code>tree</code> and <code>node</code> and is called after the <code>node</code> is closed.  Additionally the callback function <strong>must</strong> accept additional keyword arguments (<code>kwargs</code>)  which are set in the following ways:</p><ol><li>If the node is infeasible the kwarg <code>node_infeasible</code> is set to <code>true</code>.</li><li>If the node has a higher lower bound than the incumbent the kwarg <code>worse_than_incumbent</code> is set to <code>true</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L225-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.set_node_bound!-Tuple{Symbol, AbstractNode, Any, Any}" href="#Bonobo.set_node_bound!-Tuple{Symbol, AbstractNode, Any, Any}"><code>Bonobo.set_node_bound!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_node_bound!(objective_sense::Symbol, node::AbstractNode, lb, ub)</code></pre><p>Set the bounds of the <code>node</code> object to the lower and upper bound given.  Internally everything is stored as a minimization problem. Therefore the objective_sense <code>:Min</code>/<code>:Max</code> is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.set_root!-Tuple{BnBTree, NamedTuple}" href="#Bonobo.set_root!-Tuple{BnBTree, NamedTuple}"><code>Bonobo.set_root!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_root!(tree::BnBTree, node_info::NamedTuple)</code></pre><p>Set the root node information based on the <code>node_info</code> which needs to include the same fields as the <code>Node</code> struct given  to the <a href="#Bonobo.initialize-Tuple{}"><code>initialize</code></a> method. (Besides the <code>std</code> field which is set by Bonobo automatically)</p><p><strong>Example</strong></p><p>If your node structure is the following:</p><pre><code class="language-julia hljs">mutable struct MIPNode &lt;: AbstractNode
    std :: BnBNodeInfo
    lbs :: Vector{Float64}
    ubs :: Vector{Float64}
    status :: MOI.TerminationStatusCode
end</code></pre><p>then you can call the function with this syntax:</p><pre><code class="language-julia hljs">Bonobo.set_root!(tree, (
    lbs = fill(-Inf, length(x)),
    ubs = fill(Inf, length(x)),
    status = MOI.OPTIMIZE_NOT_CALLED
))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/node.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.sort_solutions!-Tuple{Vector{&lt;:AbstractSolution}}" href="#Bonobo.sort_solutions!-Tuple{Vector{&lt;:AbstractSolution}}"><code>Bonobo.sort_solutions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_solutions!(solutions::Vector{&lt;:AbstractSolution})</code></pre><p>Sort the solutions vector by objective value such that the best solution is at index 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L302-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.terminated-Tuple{BnBTree}" href="#Bonobo.terminated-Tuple{BnBTree}"><code>Bonobo.terminated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">terminated(tree::BnBTree)</code></pre><p>Return true when the branch-and-bound loop in <a href="#Bonobo.optimize!-Tuple{BnBTree}"><code>optimize!</code></a> should be terminated. Default behavior is to terminate the loop only when no nodes exist in the priority queue or when the relative or absolute duality gap are below the tolerances fixed in the options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L311-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bonobo.update_best_solution!-Tuple{BnBTree, AbstractNode}" href="#Bonobo.update_best_solution!-Tuple{BnBTree, AbstractNode}"><code>Bonobo.update_best_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_best_solution!(tree::BnBTree, node::AbstractNode)</code></pre><p>Update the best solution when we found a better incumbent. Calls [<code>add_new_solution!</code>] if this is the case, returns whether a solution was added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Wikunia/Bonobo.jl/blob/abfd651dfe2b3103f78caedfd9b3d7d739efa4e8/src/Bonobo.jl#L375-L380">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how_to/">« How-To</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 28 December 2025 19:38">Sunday 28 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
