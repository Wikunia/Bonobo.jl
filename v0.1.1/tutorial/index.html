<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Bonobo.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Wikunia.github.io/Bonobo.jl/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bonobo.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-MIP-Solver-using-a-LP-solver"><span>Creating a MIP Solver using a LP solver</span></a></li></ul></li><li><a class="tocitem" href="../how_to/">How-To</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Wikunia/Bonobo.jl/blob/master/docs/src/tutorial.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Creating-a-MIP-Solver-using-a-LP-solver"><a class="docs-heading-anchor" href="#Creating-a-MIP-Solver-using-a-LP-solver">Creating a MIP Solver using a LP solver</a><a id="Creating-a-MIP-Solver-using-a-LP-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-MIP-Solver-using-a-LP-solver" title="Permalink"></a></h2><p>In this short tutorial you&#39;ll use a LP solver <a href="https://github.com/jump-dev/HiGHS.jl">HiGHS.jl</a> and use it as a MIP solver. <strong>Attention:</strong> HiGHS itself can solve MIP problems as well so if you don&#39;t want to experiment with your own branching strategies you probably don&#39;t want to use Bonobo.</p><p>First we create the LP problem using <a href="https://github.com/jump-dev/JuMP.jl">JuMP.jl</a> and HiGHS.jl:</p><pre><code class="nohighlight hljs">using Bonobo
using JuMP
using HiGHS

const BB = Bonobo</code></pre><p>Those need to be installed with <code>] add Bonobo, JuMP, HiGHS</code>.</p><p>A standard LP model:</p><pre><code class="nohighlight hljs">m = Model(HiGHS.Optimizer)
set_optimizer_attribute(m, &quot;log_to_console&quot;, false)
@variable(m, x[1:3] &gt;= 0)
@constraint(m, 0.5x[1]+3.1x[2]+4.2x[3] &gt;= 6.1)   
@constraint(m, 1.9x[1]+0.7x[2]+0.2x[3] &gt;= 8.1)   
@constraint(m, 2.9x[1]-2.3x[2]+4.2x[3] &gt;= 10.5)   
@objective(m, Min, x[1]+1.2x[2]+3.2x[3])</code></pre><p>Now we need to initialize the branch and bound solver:</p><pre><code class="nohighlight hljs">bnb_model = BB.initialize(; 
    branch_strategy = BB.MOST_INFEASIBLE,
    Node = MIPNode,
    root = m,
    sense = objective_sense(m) == MOI.MAX_SENSE ? :Max : :Min
)</code></pre><p>Here we use the branch strategy <code>MOST_INFEASIBLE</code>, we want to use our own node type <code>MIPNode</code> which shall hold information about the current lower and upper bounds of each variable. Then we give Bonobo the model/root information and the objective sense.</p><p>Let&#39;s define our <code>MIPNode</code>:</p><pre><code class="nohighlight hljs">mutable struct MIPNode &lt;: AbstractNode
    std :: BnBNodeInfo
    lbs :: Vector{Float64}
    ubs :: Vector{Float64}
    status :: MOI.TerminationStatusCode
end</code></pre><p>The two things we need to be aware of is that it has to be an <code>AbstractNode</code> and it needs the field: <code>std::BnBNodeInfo</code>.</p><p>The <a href="@ref"><code>initialize</code></a> function also calls <code>get_branching_indices(::Model)</code> where <code>Model</code> is the type of our root node. There one needs to specify the variables that one can branch on. In our case we want to branch on all variables so we define:</p><pre><code class="nohighlight hljs">function BB.get_branching_indices(model::JuMP.Model)
    # every variable should be discrete
    vis = MOI.get(model, MOI.ListOfVariableIndices())
    return 1:length(vis)
end</code></pre><p>Next we need to specify the information we have about the root node using <a href="@ref"><code>set_root!</code></a>. This will be the info that is send to <a href="@ref"><code>evaluate_node!</code></a> at the very beginning.</p><pre><code class="nohighlight hljs">BB.set_root!(bnb_model, (
    lbs = zeros(length(x)),
    ubs = fill(Inf, length(x)),
    status = MOI.OPTIMIZE_NOT_CALLED
))</code></pre><p>We define the lower bounds of each variable as <code>0</code> as we defined them in the model <code>@variable(m, x[1:3] &gt;= 0)</code>. There are no upper bounds. We also specify the status of this node. Important is that we specify all fields of our <code>MIPNode</code> besides the <code>std</code> field.</p><p>Now we can call <a href="ref"><code>optimize!</code></a> and see which methods still need to be implemented.</p><pre><code class="nohighlight hljs">BB.optimize!(bnb_model)</code></pre><p>It will show the following error:</p><pre><code class="nohighlight hljs">ERROR: MethodError: no method matching evaluate_node!(::BnBTree{MIPNode, Model, Vector{Float64}, Bonobo.DefaultSolution{MIPNode, Vector{Float64}}}, ::MIPNode)</code></pre><p>This means we need to define a method to evaluate a node and return back a lower and upper bound.</p><pre><code class="nohighlight hljs">function BB.evaluate_node!(tree::BnBTree{MIPNode, JuMP.Model}, node::MIPNode)
    m = tree.root # this is the JuMP.Model
    vids = MOI.get(m ,MOI.ListOfVariableIndices())
    # we set the bounds for the current node based on `node.lbs` and `node.ubs`.
    vars = VariableRef.(m, vids)
    for vidx in eachindex(vars)
        if isfinite(node.lbs[vidx])
            JuMP.set_lower_bound(vars[vidx], node.lbs[vidx])
        elseif node.lbs[vidx] == -Inf &amp;&amp; JuMP.has_lower_bound(vars[vidx])
            JuMP.delete_lower_bound(vars[vidx])
        elseif node.lbs[vidx] == Inf # making problem infeasible
            error(&quot;Invalid lower bound for variable $vidx: $(node.lbs[vidx])&quot;)
        end
        if isfinite(node.ubs[vidx])
            JuMP.set_upper_bound(vars[vidx], node.ubs[vidx])
        elseif node.ubs[vidx] == Inf &amp;&amp; JuMP.has_upper_bound(vars[vidx])
            JuMP.delete_upper_bound(vars[vidx])
        elseif node.ubs[vidx] == -Inf # making problem infeasible
            error(&quot;Invalid upper bound for variable $vidx: $(node.lbs[vidx])&quot;)
        end
    end

    # get the relaxed solution of the current model using HiGHS
    optimize!(m)
    status = termination_status(m)
    node.status = status
    # if it is infeasible we return `NaN` for bother lower and upper bound
    if status != MOI.OPTIMAL
        return NaN,NaN
    end

    obj_val = objective_value(m)
    # we check whether the values are approximately feasible (are integer)
    # in that case we return the same value for lower and upper bound for this node
    if all(BB.is_approx_feasible.(tree, value.(vars)))
        node.ub = obj_val
        return obj_val, obj_val
    end
    # otherwise we only have a lower bound
    return obj_val, NaN
end</code></pre><p>now calling <code>BB.optimize!(bnb_model)</code> again will give the following error:</p><pre><code class="nohighlight hljs">ERROR: MethodError: no method matching get_relaxed_values(::BnBTree{MIPNode, Model, Vector{Float64}, Bonobo.DefaultSolution{MIPNode, Vector{Float64}}}, ::MIPNode)
Stacktrace:
 [1] get_branching_variable(tree::BnBTree{MIPNode, Model, Vector{Float64}, Bonobo.DefaultSolution{MIPNode, Vector{Float64}}}, #unused#::Bonobo.MOST_INFEASIBLE, node::MIPNode)</code></pre><p>This gets called to figure out the next branching variable as you can see in the stacktrace where we can see that the <code>::MOST_INFEASIBLE</code> strategy is used as specified in the <a href="@ref"><code>initialize</code></a> call.</p><pre><code class="nohighlight hljs">function BB.get_relaxed_values(tree::BnBTree{MIPNode, JuMP.Model}, node)
    vids = MOI.get(tree.root, MOI.ListOfVariableIndices())
    vars = VariableRef.(tree.root, vids)
    return JuMP.value.(vars)
end</code></pre><p>We simply need to return the current values of all the variables. The last thing we need to implement is how we want to branch on a node by defining <a href="@ref"><code>get_branching_nodes_info</code></a>.</p><p>It takes as input the <code>tree</code>, the current <code>node</code> as well as the variable index to branch on.  This function shall return all information about new nodes we want to create. In our case we want to create two new nodes one where we set the upper bound below the current relaxed value and one where we set the lower bound about the relaxed value. The only thing one needs to take care of is that one doesn&#39;t remove an actual discrete solution by splitting up the current problem into  two or more subproblems.</p><p>The information for the nodes needs to be returned as a vector of <code>NamedTuple</code> which consist of the same fields as in the <code>set_root!</code> call earlier.</p><pre><code class="nohighlight hljs">function BB.get_branching_nodes_info(tree::BnBTree{MIPNode, JuMP.Model}, node::MIPNode, vidx::Int)
    m = tree.root
    node_info = NamedTuple[]

    var = VariableRef(m, MOI.VariableIndex(vidx))

    lbs = copy(node.lbs)
    ubs = copy(node.ubs)

    val = JuMP.value(var)

    # left child set upper bound
    ubs[vidx] = floor(Int, val)

    push!(node_info, (
        lbs = copy(node.lbs),
        ubs = ubs,
        status = MOI.OPTIMIZE_NOT_CALLED,
    ))

    # right child set lower bound
    lbs[vidx] = ceil(Int, val)

    push!(node_info, (
        lbs = lbs,
        ubs = copy(node.ubs),
        status = MOI.OPTIMIZE_NOT_CALLED,
    ))
    return node_info
end</code></pre><p>Now we can actually solve our problem with <code>BB.optimize!(bnb_model)</code>. Afterwards we can retrieve the optimal solution with:</p><pre><code class="nohighlight hljs">julia&gt; BB.get_solution(bnb_model)
3-element Vector{Float64}:
 5.999999999999998
 1.0
 0.0</code></pre><p>and the objective value:</p><pre><code class="nohighlight hljs">julia&gt; BB.get_objective_value(bnb_model)
7.199999999999998</code></pre><h3 id="Recap"><a class="docs-heading-anchor" href="#Recap">Recap</a><a id="Recap-1"></a><a class="docs-heading-anchor-permalink" href="#Recap" title="Permalink"></a></h3><p>The main three functions that need to be called to optimize a problem using Bonobo are for using it as a JuMP MIP solver are <a href="@ref"><code>initialize</code></a>, <a href="@ref"><code>set_root!</code></a> and <a href="@ref">`optimize!</a>.</p><pre><code class="nohighlight hljs">m = Model(HiGHS.Optimizer)
set_optimizer_attribute(m, &quot;log_to_console&quot;, false)
@variable(m, x[1:3] &gt;= 0)
@constraint(m, 0.5x[1]+3.1x[2]+4.2x[3] &gt;= 6.1)   
@constraint(m, 1.9x[1]+0.7x[2]+0.2x[3] &gt;= 8.1)   
@constraint(m, 2.9x[1]-2.3x[2]+4.2x[3] &gt;= 10.5)   
@objective(m, Min, x[1]+1.2x[2]+3.2x[3])

bnb_model = BB.initialize(; 
    branch_strategy = BB.MOST_INFEASIBLE,
    Node = MIPNode,
    root = m,
    sense = objective_sense(m) == MOI.MAX_SENSE ? :Max : :Min
)

BB.set_root!(bnb_model, (
    lbs = zeros(length(x)),
    ubs = fill(Inf, length(x)),
    status = MOI.OPTIMIZE_NOT_CALLED
))

BB.optimize!(bnb_model)</code></pre><p>The functions that get called internally and need to be implemented are: <a href="@ref"><code>get_branching_indices</code></a>, <a href="@ref"><code>evaluate_node!</code></a>, [<code>get_relaxed_values</code>] and <a href="@ref"><code>get_branching_nodes_info</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../how_to/">How-To »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 9 May 2022 17:54">Monday 9 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
